<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>zapata.computation API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', ' ', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>zapata.computation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Hashable,
    Iterable,
    List,
    Mapping,
    Optional,
    Sequence,
    Tuple,
    TypeVar,
    Union,
    cast,
)
import math
import numpy as np
import matplotlib.pyplot as plt
import scipy.linalg as sc
import numpy.linalg as lin
import xarray as xr
import pandas as pd
import cartopy.crs as car

import scipy.ndimage as ndimage

import zapata.lib as lib
import zapata.data as era

from geocat.viz import cmaps as gvcmaps
from geocat.viz import util as gvutil
import tqdm as tm
import mpl_toolkits.axes_grid1 as tl

def zonal_var(dataset,var,season,option=&#39;LonTime&#39;,verbose=False):
    &#34;&#34;&#34;
    A routine to average xarray 
    
    This routine will accept xarray up to four dimensions (lat,lon,pressure, time) and return the averaged arrays with compatible dimensions.
    
    Parameters
    ----------
    dataset :      
        Name of the dataset, ``ERA5``, ``GPCP``       
    var :   
        Variable
    season :     
        Month or Season. Resolved from `dat_param`
    option :       
        Control Averaging   
            -  None        No Averaging   
            - &#39;LonTime&#39;    Longitude and Time   
            - &#39;Lon&#39;        Longitude    
            - &#39;Time&#39;       Time averaging   
    verbose:    
        Tons of Output
    
    Returns
    --------
    
    average :
        Average. The dimension is depending on the averaging option chosen
    
    Examples
    --------
    
    &gt;&gt;&gt; zonal_var(&#39;ERA5&#39;,&#39;Z&#39;,&#39;JAN&#39;,option=&#39;LonTime&#39;)   #Longitude and Time Average for Z from ERA5
    &gt;&gt;&gt; zonal_var(&#39;GPCP&#39;,&#39;TPREP&#39;,&#39;DJF&#39;,option=&#39;Time&#39;,verbose=True)   # Time average 
    &#34;&#34;&#34;

    info=era.DataGrid()
    lev=info[dataset][var][&#39;level&#39;]
    nlev=len(lev)
    xx=era.read_xarray(dataset=&#39;ERA5&#39;,var=var,level=str(lev[0]),season=season,verbose=verbose)
    
    if option == &#39;LonTime&#39;:
        zon=xr.DataArray.expand_dims(xx.mean(dim=&#39;lon&#39;).mean(dim=&#39;time&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[0]])
        print(&#39; Averaging on longitude and time &#39;)
    elif option == &#39;Time&#39;:
        zon=xr.DataArray.expand_dims(xx.mean(dim=&#39;time&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[0]])
        print(&#39; Averaging on  time &#39;)
    elif option == &#39;Lon&#39;:
        zon=xr.DataArray.expand_dims(xx.mean(dim=&#39;lon&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[0]])
        print(&#39; Averaging on longitude &#39;)
    else:
        zon=xr.DataArray.expand_dims(xx,dim=&#39;pressure&#39;).assign_coords(pressure=[lev[0]])

    for i in tm.tnrange(1,nlev):
        xx=era.read_xarray(dataset=&#39;ERA5&#39;,var=var,level=str(lev[i]),season=season)
        if option == &#39;LonTime&#39;:
            xx1=xr.DataArray.expand_dims(xx.mean(dim=&#39;lon&#39;).mean(dim=&#39;time&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[i]])
        elif option == &#39;Time&#39;:
            xx1=xr.DataArray.expand_dims(xx.mean(dim=&#39;time&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[i]])
        elif option == &#39;Lon&#39;:
            xx1=xr.DataArray.expand_dims(xx.mean(dim=&#39;lon&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[i]])
        else:
            xx1=xr.DataArray.expand_dims(xx,dim=&#39;pressure&#39;).assign_coords(pressure=[lev[i]])       
        zon=xr.concat([zon,xx1],dim=&#39;pressure&#39;)
        
    return zon

def smooth_xarray(X,sigma=5,order=0,mode=&#39;wrap&#39;):
    &#34;&#34;&#34;
    Smooth xarray X with a gaussian filter . 

    It uses a routine from scipy ndimage ( ``ndimage.gaussian_filter``). 
    The filter is applied to all dimensions.
    See the doc page of ( ``ndimage.gaussian_filter``) for a full documentation.
    The filter can be used for periodic fields, then the correct setting of `mode` is &#39;wrap&#39;

    Parameters
    -----------
    X :  
        Input Xarray    
    
    sigma:  
        Standard deviation for the Gaussian kernel

    order:  
        Order of the smoothing, 0 is a simple convolution
    
    mode:   

        The mode parameter determines how the input array is extended when the filter overlaps a border. 
        By passing a sequence of modes with length equal to the number of dimensions of the input array, 
        different modes can be specified along each axis. Default value is ‘reflect’. 
        The valid values and their behavior is as follows:

        ‘reflect’ (d c b a | a b c d | d c b a)
        The input is extended by reflecting about the edge of the last pixel.
        
        ‘constant’ (k k k k | a b c d | k k k k)
        The input is extended by filling all values beyond the edge with the same constant value, defined by the cval parameter.
        
        ‘nearest’ (a a a a | a b c d | d d d d)
        The input is extended by replicating the last pixel.

        ‘mirror’ (d c b | a b c d | c b a)
        The input is extended by reflecting about the center of the last pixel.

        ‘wrap’ (a b c d | a b c d | a b c d)
        The input is extended by wrapping around to the opposite edge.

    Returns
    --------
    smooth_array:   
        Smoothed array

    Examples
    --------
    _Smooth a X[lat,lon] array with nearest repetition in `lat` and periodicity in `lon`_
    &gt;&gt;&gt; smooth_array(X,sigma=5,order=0,mode=[&#39;nearest&#39;,&#39;wrap&#39;]) 
    
    &#34;&#34;&#34;
    lat = X.lat
    lon = X.lon
    temp = ndimage.gaussian_filter(X, sigma=sigma, order=order,mode=mode)
    zarray = xr.DataArray(temp,dims=(&#39;lat&#39;,&#39;lon&#39;),coords={&#39;lat&#39;:lat,&#39;lon&#39;:lon})
    return zarray

def anomaly(var,option=&#39;anom&#39;,freq=&#39;month&#39;):
    &#34;&#34;&#34;
    Compute Anomalies according to &#39;option&#39;.

    Long description here.

    Parameters
    ----------

    var :   
        xarray to compute anomalies

    option :    
        &#39;deviation&#39; _Subtract the total time mean of the time series_   
        &#39;anom&#39;      _Compute anomalies from monthly climatology_    
        &#39;anomstd&#39;   _Compute standardized anomalies from monthly climatology_

    freq :  
        Frequency of data   

    Returns
    -------

    anom :  xarray

    &#34;&#34;&#34;
    frequency = &#39;time.&#39; + freq
    if option == &#39;deviation&#39;:
        anom = var - var.mean(dim=&#39;time&#39;)
    elif option == &#39;anom&#39;:
        clim = var.groupby(frequency).mean(&#34;time&#34;)
        anom = var.groupby(frequency) - clim
    elif option == &#39;anomstd&#39;:
        clim = var.groupby(frequency).mean(&#34;time&#34;)
        climstd = var.groupby(frequency).std(&#34;time&#34;)
        anom = xr.apply_ufunc(lambda x, m, s: (x - m) / s,
                var.groupby(frequency),
                clim,
                climstd )
    else:
        print(&#39; Wrong option in `anomaly` {}&#39;.format(option))
        raise SystemExit

    return anom
class Xmat():
    &#34;&#34;&#34; This class creates xarrays in mathematical form.

    The xarray is stacked along `dims` dimensions
    with the spatial values as column vectors and time as the 
    number of columns
    
    Examples    
    --------    
    Create a stacked data matrix along the &#39;lon&#39; &#39;lat dimension
    &gt;&gt;&gt; Z = Xmat(X, dims=(&#39;lat&#39;,&#39;lon&#39;))
    &#34;&#34;&#34;

    __slots__ = (&#39;A&#39;,&#39;_ntime&#39;)

    def __init__(
        self,
        X,
        dims: Union[Hashable, Sequence[Hashable], None] = None,
        ):
        self.A = X.stack(z=dims).transpose()
        &#34;&#34;&#34;Stacked Matrix of type `xarray`&#34;&#34;&#34;
        self._ntime = len(X.time.data)
        print(&#39; Created mathematical matrix A, \n \
                stacked along dimensions {} &#39;.format(dims))
        
        

    def __call__(self, v ):
        &#39;&#39;&#39; Matrix vector evaluation.&#39;&#39;&#39;
        f = self.a @ v
        return f

    def __repr__(self):
        &#39;&#39;&#39;  Printing Information &#39;&#39;&#39;
        print(&#39; \n Math Data Matrix \n {} \n&#39;.format(self.A))
        print(f&#39; Shape of A numpy array {self.A.shape}&#39;)
        return  &#39;\n&#39;
     
    def svd(self, N=10):
        &#39;&#39;&#39;Compute SVD of Data Matrix A.
        
        The calculation is done in a way that the modes are equivalent to EOF

        Parameters
        ----------
        
        N :  
            Number of modes desired.     
            If it is larger than the number of `time` levels    
            then it is set to the maximum

        Results
        -------

        out : dictionary
            Dictionary including    
        * **Pattern**               EOF patterns    
        * **Singular_Values**       Singular Values 
        * **Coefficient**           Time Coefficients   
        * **Varex**                 Variance Explained  

        Examples         
        --------     
        &gt;&gt;&gt; out = Z.svd(N=10)   
        &#39;&#39;&#39;
        #Limit to maximum modes to time levels
        Neig = np.min([N,self._ntime])
        print(f&#39;Computing {Neig} Modes&#39;)
        # Prepare arrays
        len_modes = self._ntime
        u = self.A.isel(time=range(Neig)).rename({&#39;time&#39;: &#39;Number&#39;}).assign_coords(Number= range(Neig))
        u.name = &#39;Modes&#39;
        
        #Compute modes
        _u,_s,_v=sc.svd(self.A,full_matrices=False)
    
        #EOF Patterns
        u.data = _u[:,0:Neig]
        #Singular values
        s = xr.DataArray(_s[0:Neig], dims=&#39;Modes&#39;,coords=[np.arange(Neig)])
        #Coefficients
        vcoeff = xr.DataArray(_v[0:Neig,:], dims=[&#39;Modes&#39;,&#39;Time&#39;],coords=[np.arange(Neig),self.A.time.data])
        # Compute variance explained
        _varex = _s**2/sum(_s**2)
        varex = xr.DataArray(_varex[0:Neig], dims=&#39;Modes&#39;,coords=[np.arange(Neig)])

        #Output
        out = xr.Dataset({&#39;Pattern&#39;:u,&#39;Singular_Values&#39;: s, &#39;Coefficient&#39;: vcoeff, &#39;Varex&#39;: varex})
        return out

    def corr(self,y, Dim =(&#39;time&#39;) ):
        &#34;&#34;&#34;
        Compute correlation of data matrix `A` with index `y`.

        This method compute the correlation of the data matrix
        with an index of the same length of the `time` dimension of `A`

        Parameters
        ----------
        y : xarray  
            Index, should have the same dimension length `time` 
        
        Examples
        --------
        Correlation of data matrix `Z` with `index`
        &gt;&gt;&gt; corr = Z.corr(index)
        &#34;&#34;&#34;
        index= y - y.mean(dim=Dim)
        _corr = (self.A - self.A.mean(dim=Dim)).dot(index)
        return _corr / (self.A.std(dim=Dim) * y.std(dim=Dim))/self._ntime
    
    def cov(self,y, Dim =(&#39;time&#39;) ):
        &#34;&#34;&#34;
        Compute covariance of data matrix `A` with `index`.

        This method compute the correlation of the data matrix
        with an index of the same length of the `time` dimension of `A`

        Example
        -------
        Covariance of data matrix `Z` with `index`
        &gt;&gt;&gt; cov = Z.cov(index)

        &#34;&#34;&#34;
        index= (y - y.mean(dim=Dim))
        _cov = (self.A - self.A.mean(dim=Dim)).dot(index)/self._ntime
        return _cov

    def anom(self,**kw):
        &#34;&#34;&#34; Creates anomalies.

        This is using the function `anomaly` from `zapata.computation` 
        &#34;&#34;&#34;

        self.A = anomaly(self.A,**kw)
        return 
    
      </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="zapata.computation.anomaly"><code class="name flex">
<span>def <span class="ident">anomaly</span></span>(<span>var, option='anom', freq='month')</span>
</code></dt>
<dd>
<section class="desc"><p>Compute Anomalies according to 'option'.</p>
<p>Long description here.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>var</code></strong> :&ensp;</dt>
<dd>xarray to compute anomalies</dd>
<dt><strong><code>option</code></strong> :&ensp;</dt>
<dd>'deviation' <em>Subtract the total time mean of the time series</em> <br>
'anom'
<em>Compute anomalies from monthly climatology</em>
<br>
'anomstd'
<em>Compute standardized anomalies from monthly climatology</em></dd>
<dt><strong><code>freq</code></strong> :&ensp;</dt>
<dd>Frequency of data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>anom</code></strong> :&ensp; <code>xarray</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anomaly(var,option=&#39;anom&#39;,freq=&#39;month&#39;):
    &#34;&#34;&#34;
    Compute Anomalies according to &#39;option&#39;.

    Long description here.

    Parameters
    ----------

    var :   
        xarray to compute anomalies

    option :    
        &#39;deviation&#39; _Subtract the total time mean of the time series_   
        &#39;anom&#39;      _Compute anomalies from monthly climatology_    
        &#39;anomstd&#39;   _Compute standardized anomalies from monthly climatology_

    freq :  
        Frequency of data   

    Returns
    -------

    anom :  xarray

    &#34;&#34;&#34;
    frequency = &#39;time.&#39; + freq
    if option == &#39;deviation&#39;:
        anom = var - var.mean(dim=&#39;time&#39;)
    elif option == &#39;anom&#39;:
        clim = var.groupby(frequency).mean(&#34;time&#34;)
        anom = var.groupby(frequency) - clim
    elif option == &#39;anomstd&#39;:
        clim = var.groupby(frequency).mean(&#34;time&#34;)
        climstd = var.groupby(frequency).std(&#34;time&#34;)
        anom = xr.apply_ufunc(lambda x, m, s: (x - m) / s,
                var.groupby(frequency),
                clim,
                climstd )
    else:
        print(&#39; Wrong option in `anomaly` {}&#39;.format(option))
        raise SystemExit

    return anom</code></pre>
</details>
</dd>
<dt id="zapata.computation.smooth_xarray"><code class="name flex">
<span>def <span class="ident">smooth_xarray</span></span>(<span>X, sigma=5, order=0, mode='wrap')</span>
</code></dt>
<dd>
<section class="desc"><p>Smooth xarray X with a gaussian filter . </p>
<p>It uses a routine from scipy ndimage ( <code>ndimage.gaussian_filter</code>).
The filter is applied to all dimensions.
See the doc page of ( <code>ndimage.gaussian_filter</code>) for a full documentation.
The filter can be used for periodic fields, then the correct setting of <code>mode</code> is 'wrap'</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;</dt>
<dd>Input Xarray</dd>
<dt><strong><code>sigma</code></strong> :&ensp;</dt>
<dd>Standard deviation for the Gaussian kernel</dd>
<dt><strong><code>order</code></strong> :&ensp;</dt>
<dd>Order of the smoothing, 0 is a simple convolution</dd>
<dt><strong><code>mode</code></strong> :&ensp;</dt>
<dd>
<p>The mode parameter determines how the input array is extended when the filter overlaps a border.
By passing a sequence of modes with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is ‘reflect’.
The valid values and their behavior is as follows:</p>
<p>‘reflect’ (d c b a | a b c d | d c b a)
The input is extended by reflecting about the edge of the last pixel.</p>
<p>‘constant’ (k k k k | a b c d | k k k k)
The input is extended by filling all values beyond the edge with the same constant value, defined by the cval parameter.</p>
<p>‘nearest’ (a a a a | a b c d | d d d d)
The input is extended by replicating the last pixel.</p>
<p>‘mirror’ (d c b | a b c d | c b a)
The input is extended by reflecting about the center of the last pixel.</p>
<p>‘wrap’ (a b c d | a b c d | a b c d)
The input is extended by wrapping around to the opposite edge.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>smooth_array</code></strong> :&ensp;</dt>
<dd>Smoothed array</dd>
</dl>
<h2 id="examples">Examples</h2>
<p><em>Smooth a X[lat,lon] array with nearest repetition in <code>lat</code> and periodicity in <code>lon</code></em></p>
<pre><code>&gt;&gt;&gt; smooth_array(X,sigma=5,order=0,mode=['nearest','wrap'])
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smooth_xarray(X,sigma=5,order=0,mode=&#39;wrap&#39;):
    &#34;&#34;&#34;
    Smooth xarray X with a gaussian filter . 

    It uses a routine from scipy ndimage ( ``ndimage.gaussian_filter``). 
    The filter is applied to all dimensions.
    See the doc page of ( ``ndimage.gaussian_filter``) for a full documentation.
    The filter can be used for periodic fields, then the correct setting of `mode` is &#39;wrap&#39;

    Parameters
    -----------
    X :  
        Input Xarray    
    
    sigma:  
        Standard deviation for the Gaussian kernel

    order:  
        Order of the smoothing, 0 is a simple convolution
    
    mode:   

        The mode parameter determines how the input array is extended when the filter overlaps a border. 
        By passing a sequence of modes with length equal to the number of dimensions of the input array, 
        different modes can be specified along each axis. Default value is ‘reflect’. 
        The valid values and their behavior is as follows:

        ‘reflect’ (d c b a | a b c d | d c b a)
        The input is extended by reflecting about the edge of the last pixel.
        
        ‘constant’ (k k k k | a b c d | k k k k)
        The input is extended by filling all values beyond the edge with the same constant value, defined by the cval parameter.
        
        ‘nearest’ (a a a a | a b c d | d d d d)
        The input is extended by replicating the last pixel.

        ‘mirror’ (d c b | a b c d | c b a)
        The input is extended by reflecting about the center of the last pixel.

        ‘wrap’ (a b c d | a b c d | a b c d)
        The input is extended by wrapping around to the opposite edge.

    Returns
    --------
    smooth_array:   
        Smoothed array

    Examples
    --------
    _Smooth a X[lat,lon] array with nearest repetition in `lat` and periodicity in `lon`_
    &gt;&gt;&gt; smooth_array(X,sigma=5,order=0,mode=[&#39;nearest&#39;,&#39;wrap&#39;]) 
    
    &#34;&#34;&#34;
    lat = X.lat
    lon = X.lon
    temp = ndimage.gaussian_filter(X, sigma=sigma, order=order,mode=mode)
    zarray = xr.DataArray(temp,dims=(&#39;lat&#39;,&#39;lon&#39;),coords={&#39;lat&#39;:lat,&#39;lon&#39;:lon})
    return zarray</code></pre>
</details>
</dd>
<dt id="zapata.computation.zonal_var"><code class="name flex">
<span>def <span class="ident">zonal_var</span></span>(<span>dataset, var, season, option='LonTime', verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>A routine to average xarray </p>
<p>This routine will accept xarray up to four dimensions (lat,lon,pressure, time) and return the averaged arrays with compatible dimensions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataset</code></strong> :&ensp;</dt>
<dd>Name of the dataset, <code>ERA5</code>, <code>GPCP</code></dd>
<dt><strong><code>var</code></strong> :&ensp;</dt>
<dd>Variable</dd>
<dt><strong><code>season</code></strong> :&ensp;</dt>
<dd>Month or Season. Resolved from <code>dat_param</code></dd>
<dt><strong><code>option</code></strong> :&ensp;</dt>
<dd>Control Averaging <br>
-
None
No Averaging <br>
- 'LonTime'
Longitude and Time <br>
- 'Lon'
Longitude
<br>
- 'Time'
Time averaging</dd>
<dt><strong><code>verbose</code></strong> :&ensp;</dt>
<dd>Tons of Output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>average</code> :</dt>
<dd>Average. The dimension is depending on the averaging option chosen</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; zonal_var('ERA5','Z','JAN',option='LonTime')   #Longitude and Time Average for Z from ERA5
&gt;&gt;&gt; zonal_var('GPCP','TPREP','DJF',option='Time',verbose=True)   # Time average
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zonal_var(dataset,var,season,option=&#39;LonTime&#39;,verbose=False):
    &#34;&#34;&#34;
    A routine to average xarray 
    
    This routine will accept xarray up to four dimensions (lat,lon,pressure, time) and return the averaged arrays with compatible dimensions.
    
    Parameters
    ----------
    dataset :      
        Name of the dataset, ``ERA5``, ``GPCP``       
    var :   
        Variable
    season :     
        Month or Season. Resolved from `dat_param`
    option :       
        Control Averaging   
            -  None        No Averaging   
            - &#39;LonTime&#39;    Longitude and Time   
            - &#39;Lon&#39;        Longitude    
            - &#39;Time&#39;       Time averaging   
    verbose:    
        Tons of Output
    
    Returns
    --------
    
    average :
        Average. The dimension is depending on the averaging option chosen
    
    Examples
    --------
    
    &gt;&gt;&gt; zonal_var(&#39;ERA5&#39;,&#39;Z&#39;,&#39;JAN&#39;,option=&#39;LonTime&#39;)   #Longitude and Time Average for Z from ERA5
    &gt;&gt;&gt; zonal_var(&#39;GPCP&#39;,&#39;TPREP&#39;,&#39;DJF&#39;,option=&#39;Time&#39;,verbose=True)   # Time average 
    &#34;&#34;&#34;

    info=era.DataGrid()
    lev=info[dataset][var][&#39;level&#39;]
    nlev=len(lev)
    xx=era.read_xarray(dataset=&#39;ERA5&#39;,var=var,level=str(lev[0]),season=season,verbose=verbose)
    
    if option == &#39;LonTime&#39;:
        zon=xr.DataArray.expand_dims(xx.mean(dim=&#39;lon&#39;).mean(dim=&#39;time&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[0]])
        print(&#39; Averaging on longitude and time &#39;)
    elif option == &#39;Time&#39;:
        zon=xr.DataArray.expand_dims(xx.mean(dim=&#39;time&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[0]])
        print(&#39; Averaging on  time &#39;)
    elif option == &#39;Lon&#39;:
        zon=xr.DataArray.expand_dims(xx.mean(dim=&#39;lon&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[0]])
        print(&#39; Averaging on longitude &#39;)
    else:
        zon=xr.DataArray.expand_dims(xx,dim=&#39;pressure&#39;).assign_coords(pressure=[lev[0]])

    for i in tm.tnrange(1,nlev):
        xx=era.read_xarray(dataset=&#39;ERA5&#39;,var=var,level=str(lev[i]),season=season)
        if option == &#39;LonTime&#39;:
            xx1=xr.DataArray.expand_dims(xx.mean(dim=&#39;lon&#39;).mean(dim=&#39;time&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[i]])
        elif option == &#39;Time&#39;:
            xx1=xr.DataArray.expand_dims(xx.mean(dim=&#39;time&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[i]])
        elif option == &#39;Lon&#39;:
            xx1=xr.DataArray.expand_dims(xx.mean(dim=&#39;lon&#39;),dim=&#39;pressure&#39;).assign_coords(pressure=[lev[i]])
        else:
            xx1=xr.DataArray.expand_dims(xx,dim=&#39;pressure&#39;).assign_coords(pressure=[lev[i]])       
        zon=xr.concat([zon,xx1],dim=&#39;pressure&#39;)
        
    return zon</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="zapata.computation.Xmat"><code class="flex name class">
<span>class <span class="ident">Xmat</span></span>
<span>(</span><span>X, dims: Union[Hashable, Sequence[Hashable], NoneType] = None)</span>
</code></dt>
<dd>
<section class="desc"><p>This class creates xarrays in mathematical form.</p>
<p>The xarray is stacked along <code>dims</code> dimensions
with the spatial values as column vectors and time as the
number of columns</p>
<h2 id="examples">Examples</h2>
<p>Create a stacked data matrix along the 'lon' 'lat dimension</p>
<pre><code>&gt;&gt;&gt; Z = Xmat(X, dims=('lat','lon'))
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Xmat():
    &#34;&#34;&#34; This class creates xarrays in mathematical form.

    The xarray is stacked along `dims` dimensions
    with the spatial values as column vectors and time as the 
    number of columns
    
    Examples    
    --------    
    Create a stacked data matrix along the &#39;lon&#39; &#39;lat dimension
    &gt;&gt;&gt; Z = Xmat(X, dims=(&#39;lat&#39;,&#39;lon&#39;))
    &#34;&#34;&#34;

    __slots__ = (&#39;A&#39;,&#39;_ntime&#39;)

    def __init__(
        self,
        X,
        dims: Union[Hashable, Sequence[Hashable], None] = None,
        ):
        self.A = X.stack(z=dims).transpose()
        &#34;&#34;&#34;Stacked Matrix of type `xarray`&#34;&#34;&#34;
        self._ntime = len(X.time.data)
        print(&#39; Created mathematical matrix A, \n \
                stacked along dimensions {} &#39;.format(dims))
        
        

    def __call__(self, v ):
        &#39;&#39;&#39; Matrix vector evaluation.&#39;&#39;&#39;
        f = self.a @ v
        return f

    def __repr__(self):
        &#39;&#39;&#39;  Printing Information &#39;&#39;&#39;
        print(&#39; \n Math Data Matrix \n {} \n&#39;.format(self.A))
        print(f&#39; Shape of A numpy array {self.A.shape}&#39;)
        return  &#39;\n&#39;
     
    def svd(self, N=10):
        &#39;&#39;&#39;Compute SVD of Data Matrix A.
        
        The calculation is done in a way that the modes are equivalent to EOF

        Parameters
        ----------
        
        N :  
            Number of modes desired.     
            If it is larger than the number of `time` levels    
            then it is set to the maximum

        Results
        -------

        out : dictionary
            Dictionary including    
        * **Pattern**               EOF patterns    
        * **Singular_Values**       Singular Values 
        * **Coefficient**           Time Coefficients   
        * **Varex**                 Variance Explained  

        Examples         
        --------     
        &gt;&gt;&gt; out = Z.svd(N=10)   
        &#39;&#39;&#39;
        #Limit to maximum modes to time levels
        Neig = np.min([N,self._ntime])
        print(f&#39;Computing {Neig} Modes&#39;)
        # Prepare arrays
        len_modes = self._ntime
        u = self.A.isel(time=range(Neig)).rename({&#39;time&#39;: &#39;Number&#39;}).assign_coords(Number= range(Neig))
        u.name = &#39;Modes&#39;
        
        #Compute modes
        _u,_s,_v=sc.svd(self.A,full_matrices=False)
    
        #EOF Patterns
        u.data = _u[:,0:Neig]
        #Singular values
        s = xr.DataArray(_s[0:Neig], dims=&#39;Modes&#39;,coords=[np.arange(Neig)])
        #Coefficients
        vcoeff = xr.DataArray(_v[0:Neig,:], dims=[&#39;Modes&#39;,&#39;Time&#39;],coords=[np.arange(Neig),self.A.time.data])
        # Compute variance explained
        _varex = _s**2/sum(_s**2)
        varex = xr.DataArray(_varex[0:Neig], dims=&#39;Modes&#39;,coords=[np.arange(Neig)])

        #Output
        out = xr.Dataset({&#39;Pattern&#39;:u,&#39;Singular_Values&#39;: s, &#39;Coefficient&#39;: vcoeff, &#39;Varex&#39;: varex})
        return out

    def corr(self,y, Dim =(&#39;time&#39;) ):
        &#34;&#34;&#34;
        Compute correlation of data matrix `A` with index `y`.

        This method compute the correlation of the data matrix
        with an index of the same length of the `time` dimension of `A`

        Parameters
        ----------
        y : xarray  
            Index, should have the same dimension length `time` 
        
        Examples
        --------
        Correlation of data matrix `Z` with `index`
        &gt;&gt;&gt; corr = Z.corr(index)
        &#34;&#34;&#34;
        index= y - y.mean(dim=Dim)
        _corr = (self.A - self.A.mean(dim=Dim)).dot(index)
        return _corr / (self.A.std(dim=Dim) * y.std(dim=Dim))/self._ntime
    
    def cov(self,y, Dim =(&#39;time&#39;) ):
        &#34;&#34;&#34;
        Compute covariance of data matrix `A` with `index`.

        This method compute the correlation of the data matrix
        with an index of the same length of the `time` dimension of `A`

        Example
        -------
        Covariance of data matrix `Z` with `index`
        &gt;&gt;&gt; cov = Z.cov(index)

        &#34;&#34;&#34;
        index= (y - y.mean(dim=Dim))
        _cov = (self.A - self.A.mean(dim=Dim)).dot(index)/self._ntime
        return _cov

    def anom(self,**kw):
        &#34;&#34;&#34; Creates anomalies.

        This is using the function `anomaly` from `zapata.computation` 
        &#34;&#34;&#34;

        self.A = anomaly(self.A,**kw)
        return </code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="zapata.computation.Xmat.A"><code class="name">var <span class="ident">A</span></code></dt>
<dd>
<section class="desc"><p>Stacked Matrix of type <code>xarray</code></p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="zapata.computation.Xmat.anom"><code class="name flex">
<span>def <span class="ident">anom</span></span>(<span>self, **kw)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates anomalies.</p>
<p>This is using the function <a title="zapata.computation.anomaly" href="#zapata.computation.anomaly"><code>anomaly()</code></a> from <a title="zapata.computation" href="#zapata.computation"><code>zapata.computation</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anom(self,**kw):
    &#34;&#34;&#34; Creates anomalies.

    This is using the function `anomaly` from `zapata.computation` 
    &#34;&#34;&#34;

    self.A = anomaly(self.A,**kw)
    return </code></pre>
</details>
</dd>
<dt id="zapata.computation.Xmat.corr"><code class="name flex">
<span>def <span class="ident">corr</span></span>(<span>self, y, Dim='time')</span>
</code></dt>
<dd>
<section class="desc"><p>Compute correlation of data matrix <code>A</code> with index <code>y</code>.</p>
<p>This method compute the correlation of the data matrix
with an index of the same length of the <code>time</code> dimension of <code>A</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>xarray</code></dt>
<dd>Index, should have the same dimension length <code>time</code></dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Correlation of data matrix <code>Z</code> with <code>index</code></p>
<pre><code>&gt;&gt;&gt; corr = Z.corr(index)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corr(self,y, Dim =(&#39;time&#39;) ):
    &#34;&#34;&#34;
    Compute correlation of data matrix `A` with index `y`.

    This method compute the correlation of the data matrix
    with an index of the same length of the `time` dimension of `A`

    Parameters
    ----------
    y : xarray  
        Index, should have the same dimension length `time` 
    
    Examples
    --------
    Correlation of data matrix `Z` with `index`
    &gt;&gt;&gt; corr = Z.corr(index)
    &#34;&#34;&#34;
    index= y - y.mean(dim=Dim)
    _corr = (self.A - self.A.mean(dim=Dim)).dot(index)
    return _corr / (self.A.std(dim=Dim) * y.std(dim=Dim))/self._ntime</code></pre>
</details>
</dd>
<dt id="zapata.computation.Xmat.cov"><code class="name flex">
<span>def <span class="ident">cov</span></span>(<span>self, y, Dim='time')</span>
</code></dt>
<dd>
<section class="desc"><p>Compute covariance of data matrix <code>A</code> with <code>index</code>.</p>
<p>This method compute the correlation of the data matrix
with an index of the same length of the <code>time</code> dimension of <code>A</code></p>
<h2 id="example">Example</h2>
<p>Covariance of data matrix <code>Z</code> with <code>index</code></p>
<pre><code>&gt;&gt;&gt; cov = Z.cov(index)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cov(self,y, Dim =(&#39;time&#39;) ):
    &#34;&#34;&#34;
    Compute covariance of data matrix `A` with `index`.

    This method compute the correlation of the data matrix
    with an index of the same length of the `time` dimension of `A`

    Example
    -------
    Covariance of data matrix `Z` with `index`
    &gt;&gt;&gt; cov = Z.cov(index)

    &#34;&#34;&#34;
    index= (y - y.mean(dim=Dim))
    _cov = (self.A - self.A.mean(dim=Dim)).dot(index)/self._ntime
    return _cov</code></pre>
</details>
</dd>
<dt id="zapata.computation.Xmat.svd"><code class="name flex">
<span>def <span class="ident">svd</span></span>(<span>self, N=10)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute SVD of Data Matrix A.</p>
<p>The calculation is done in a way that the modes are equivalent to EOF</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;</dt>
<dd>Number of modes desired.
<br>
If it is larger than the number of <code>time</code> levels
<br>
then it is set to the maximum</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>Dictionary including</dd>
</dl>
<ul>
<li><strong>Pattern</strong>
EOF patterns
</li>
<li><strong>Singular_Values</strong>
Singular Values </li>
<li><strong>Coefficient</strong>
Time Coefficients
</li>
<li><strong>Varex</strong>
Variance Explained
</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; out = Z.svd(N=10)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def svd(self, N=10):
    &#39;&#39;&#39;Compute SVD of Data Matrix A.
    
    The calculation is done in a way that the modes are equivalent to EOF

    Parameters
    ----------
    
    N :  
        Number of modes desired.     
        If it is larger than the number of `time` levels    
        then it is set to the maximum

    Results
    -------

    out : dictionary
        Dictionary including    
    * **Pattern**               EOF patterns    
    * **Singular_Values**       Singular Values 
    * **Coefficient**           Time Coefficients   
    * **Varex**                 Variance Explained  

    Examples         
    --------     
    &gt;&gt;&gt; out = Z.svd(N=10)   
    &#39;&#39;&#39;
    #Limit to maximum modes to time levels
    Neig = np.min([N,self._ntime])
    print(f&#39;Computing {Neig} Modes&#39;)
    # Prepare arrays
    len_modes = self._ntime
    u = self.A.isel(time=range(Neig)).rename({&#39;time&#39;: &#39;Number&#39;}).assign_coords(Number= range(Neig))
    u.name = &#39;Modes&#39;
    
    #Compute modes
    _u,_s,_v=sc.svd(self.A,full_matrices=False)

    #EOF Patterns
    u.data = _u[:,0:Neig]
    #Singular values
    s = xr.DataArray(_s[0:Neig], dims=&#39;Modes&#39;,coords=[np.arange(Neig)])
    #Coefficients
    vcoeff = xr.DataArray(_v[0:Neig,:], dims=[&#39;Modes&#39;,&#39;Time&#39;],coords=[np.arange(Neig),self.A.time.data])
    # Compute variance explained
    _varex = _s**2/sum(_s**2)
    varex = xr.DataArray(_varex[0:Neig], dims=&#39;Modes&#39;,coords=[np.arange(Neig)])

    #Output
    out = xr.Dataset({&#39;Pattern&#39;:u,&#39;Singular_Values&#39;: s, &#39;Coefficient&#39;: vcoeff, &#39;Varex&#39;: varex})
    return out</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<!DOCTYPE html>
<html>
<head>
<title>HTML img Tag</title>
</head>
<body>
<img src="../resources/zap.png" alt="Simply Easy Learning" width="400"
height="260">
</body>
</html>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="zapata" href="index.html">zapata</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="zapata.computation.anomaly" href="#zapata.computation.anomaly">anomaly</a></code></li>
<li><code><a title="zapata.computation.smooth_xarray" href="#zapata.computation.smooth_xarray">smooth_xarray</a></code></li>
<li><code><a title="zapata.computation.zonal_var" href="#zapata.computation.zonal_var">zonal_var</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="zapata.computation.Xmat" href="#zapata.computation.Xmat">Xmat</a></code></h4>
<ul class="">
<li><code><a title="zapata.computation.Xmat.A" href="#zapata.computation.Xmat.A">A</a></code></li>
<li><code><a title="zapata.computation.Xmat.anom" href="#zapata.computation.Xmat.anom">anom</a></code></li>
<li><code><a title="zapata.computation.Xmat.corr" href="#zapata.computation.Xmat.corr">corr</a></code></li>
<li><code><a title="zapata.computation.Xmat.cov" href="#zapata.computation.Xmat.cov">cov</a></code></li>
<li><code><a title="zapata.computation.Xmat.svd" href="#zapata.computation.Xmat.svd">svd</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>